#!/usr/bin/ruby
require 'openssl'
require 'securerandom'
require 'open3'
require 'io/console'

VERSION = 1
PBKDF_ALGO = "argon2id"
PBKDF_LENGTH = 32
PBKDF_SALT_LENGTH = 32
PBKDF_PARALLELISM = 4
PBKDF_MEM_KB = 2 ** 16
PBKDF_PASSES = 8
ENCRYPTION_ALGO = "ChaCha20-Poly1305"

def eprint(*args)
  STDERR.print(*args)
end

def eputs(*args)
  STDERR.puts(*args)
end

def usage()
  eputs "Usage: sigma-cipher [MODE]"
  eputs "  - [MODE] can be either 'encrypt' or 'decrypt'"
  eputs "  - password will be prompted when the program starts (every byte until new line)"
  eputs "  - input bytes (plaintext or ciphertext) are passed through stdin"
  exit 1
end

def read_password()
  chars = ""
  while (c = STDIN.getch)
    case c
      when "\03"
        eputs
        exit 1
      when "\r", "\n"
        break
      when "\b", "\x7F"
        next if chars.empty?
        chars.chop!()
        eprint "\b \b"
      when "\e"
        # consume additional characters for
        # escape sequences, like arrow inputs
        loop do
          begin
            STDIN.read_nonblock(1)
          rescue
            break
          end
        end
      else
        chars << c
        eprint "*"
    end
  end

  chars
end

def pbkdf(password_bytes, salt_bytes, length=PBKDF_LENGTH, parallelism=PBKDF_PARALLELISM, mem_kb=PBKDF_MEM_KB, passes=PBKDF_PASSES)
  command = "argon2"
  output = ""
  error = ""
  exit_code = 1
  Open3.popen3(command, salt_bytes, "-id", "-l", length.to_s, "-p", parallelism.to_s, "-k", mem_kb.to_s, "-t", passes.to_s, "-r") { |stdin, stdout, stderr, wait_thread|
    stdin.puts password_bytes
    stdin.flush
    stdin.close

    output = stdout.read
    error = stderr.read
    exit_code = wait_thread.value.exitstatus
  }

  if exit_code != 0 then
    raise "Failed to derive key from password: #{error}"
  end

  [output.chomp].pack("H*")
end

def do_encrypt(password, file=nil)
  pbkdf_salt = SecureRandom.random_bytes(PBKDF_SALT_LENGTH)
  puts "sigma-cipher-version=#{VERSION}"
  puts "pbkdf-params=#{PBKDF_ALGO},#{PBKDF_LENGTH},#{PBKDF_PARALLELISM},#{PBKDF_MEM_KB},#{PBKDF_PASSES},#{pbkdf_salt.unpack1("H*")}"

  cipher_nonce = SecureRandom.random_bytes(12)
  puts "encryption-params=#{ENCRYPTION_ALGO},#{cipher_nonce.unpack1("H*")}"

  key = pbkdf(password, pbkdf_salt)
  cipher = OpenSSL::Cipher.new ENCRYPTION_ALGO
  cipher.encrypt
  cipher.key = key
  cipher.iv = cipher_nonce
  if not file
    eputs
    eputs"Reading input from STDIN, send EOF to stop (CTRL-D)"
    print "ciphertext="
    while line = STDIN.gets
      ciphertext = cipher.update(line)
      print ciphertext.unpack1("H*")
      eputs
    end
  else
    print "ciphertext="
    chunk_size = 4096
    f = File.open(file, "rb")
    while chunk = f.read(chunk_size)
      ciphertext = cipher.update(chunk)
      print ciphertext.unpack1("H*")
    end
  end
  puts cipher.final.unpack1("H*")
  mac = cipher.auth_tag
  puts "mac=#{mac.unpack1("H*")}"
end

def do_decrypt(password, file=nil)
  stream=STDIN
  if file
    stream = File.open(file, "rb")
  end
  eprint "Enter the 'sigma-cipher-version' entry: "
  version = stream.gets&.chomp.split("=")[1].to_i(10)
  eputs

  eprint "Enter the 'pbkdf-params' entry: "
  pbkdf_params = stream.gets&.chomp.split("=")[1].split(",")
  pbkdf_salt = [pbkdf_params[-1]].pack("H*")
  eputs

  eprint "Enter the 'encryption-params' entry: "
  encryption_params = stream.gets&.chomp.split("=")[1].split(",")
  nonce = [encryption_params[-1]].pack("H*")
  eputs

  eprint "Enter the 'ciphertext' entry: "
  ciphertext = [stream.gets&.chomp.split("=")[1]].pack("H*")
  eputs

  eprint "Enter the 'mac' entry: "
  mac = [stream.gets&.chomp.split("=")[1]].pack("H*")
  eputs

  eputs "PLAINTEXT:"
  key = pbkdf(password, pbkdf_salt)
  cipher = OpenSSL::Cipher.new ENCRYPTION_ALGO
  cipher.decrypt
  cipher.key = key
  cipher.iv = nonce
  cipher.auth_tag = mac
  plaintext = cipher.update(ciphertext) + cipher.final
  puts plaintext
end

eputs "[sigma-cipher]"
file = nil
if ARGV.length < 1 then
  usage
elsif ARGV.length >= 2
  file = ARGV[1]
end

mode = ARGV[0]
if not ["encrypt", "decrypt"].include?(mode) then
  usage
end
eputs "MODE: #{mode}"

password = ""
while password.empty?
  eprint "Enter your password: "
  password = read_password
end
eputs

if mode == "encrypt"
  do_encrypt(password, file)
else
  do_decrypt(password, file)
end
